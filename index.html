<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Titled Code Demo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root {
      --bg: #0f172a;
      --panel: #111827;
      --text: #e5e7eb;
      --muted: #9ca3af;
      --accent: #22d3ee;
      --border: #1f2937;
      --btn: #0ea5e9;
      --btn-2: #14b8a6;
      --btn-3: #a78bfa;
      --radius: 12px;
    }

    html, body {
      height: 100%;
      background: radial-gradient(1200px 600px at 20% -10%, #1e293b 0%, #0b1020 40%, var(--bg) 100%);
      color: var(--text);
      margin: 0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial;
    }

    .wrap {
      max-width: 1100px;
      margin: 40px auto 80px;
      padding: 0 16px;
    }

    header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 12px;
      margin-bottom: 20px;
      flex-wrap: wrap;
    }

    h1 {
      margin: 0;
      font-size: 28px;
      letter-spacing: 0.2px;
    }

    .toolbar {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
    }

    button {
      border: none;
      border-radius: 10px;
      padding: 10px 14px;
      font-weight: 600;
      cursor: pointer;
      color: white;
      background: var(--btn);
      transition: transform .05s ease, filter .15s ease;
    }
    button:hover { filter: brightness(1.08); }
    button:active { transform: translateY(1px); }
    .btn-green { background: var(--btn-2); }
    .btn-purple { background: var(--btn-3); }

    /* 1 block per row */
    .grid {
      display: grid;
      grid-template-columns: 1fr;
      gap: 24px;
    }

    .block {
      background: linear-gradient(180deg, rgba(255,255,255,0.06), rgba(255,255,255,0.02));
      border: 1px solid var(--border);
      border-radius: var(--radius);
      overflow: hidden;
      box-shadow: 0 10px 24px rgba(0,0,0,.25);
      display: flex;
      flex-direction: column;
      min-height: 400px; /* bigger block height */
    }

    .block-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      padding: 12px;
      background: rgba(255,255,255,0.03);
      border-bottom: 1px solid var(--border);
    }

    .title {
      font-size: 15px;
      font-weight: 700;
      outline: none;
      border: none;
      background: transparent;
      color: var(--text);
      padding: 6px 8px;
      border-radius: 8px;
    }

    .code-wrap {
      position: relative;
      padding: 12px;
      flex: 1;
    }

    pre {
      margin: 0;
      overflow: auto;
      height: 100%;
      min-height: 350px; /* larger editable area */
      border-radius: 10px;
      border: 1px solid var(--border);
      background: radial-gradient(1200px 400px at 80% -80%, rgba(80,200,255,0.15), transparent 60%),
                  linear-gradient(180deg, rgba(255,255,255,0.03), rgba(255,255,255,0.01));
      padding: 14px;
      font-size: 14px;
      line-height: 1.5;
      color: #e6edf3;
    }

    code[contenteditable="true"] {
      display: block;
      white-space: pre;
      caret-color: #fff;
      outline: none;
    }

    footer {
      text-align: center;
      margin-top: 26px;
      color: var(--muted);
      font-size: 12px;
    }
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <h1>ðŸŽ¯ TPM TSS Demo</h1>
      <div class="toolbar">
        <button class="btn-green">Add New Block</button>
        <button class="btn-purple">Download All</button>
      </div>
    </header>

    <section class="grid">
      <article class="block">
        <div class="block-header">
          <div class="title" contenteditable="true">C++ Snippet</div>
          <div>
            <button>Copy</button>
            <button class="btn-green">Download</button>
          </div>
        </div>
        <div class="code-wrap">
          <pre><code contenteditable="true">
<!-- Your CODE goes here -->
Indigo::Vector<Indigo::uint8_t> TPMManager_User::unseal_nvram(
    Indigo::uint32_t nv_index,
    const Indigo::Vector<Indigo::uint8_t>& auth_value,
    const Indigo::Vector<Indigo::uint8_t>& pcrs,
    const TPM::TPMManager::HashAlgorithmEnum& pcr_bank)
{
    Indigo::Vector<Indigo::uint8_t> out; // return empty on failure

    // 1) ESAPI init
    TSS2_ABI_VERSION abi = TSS2_ABI_VERSION_CURRENT;
    ESYS_CONTEXT* esys = nullptr;
    TSS2_RC rc = Esys_Initialize(&esys, p_tcti_context, &abi);
    if (rc != TSS2_RC_SUCCESS) {
        LOG(ERROR) << "unseal_nvram: Esys_Initialize rc=0x" << std::hex << rc;
        return out;
    }

    // 2) Get an ESYS handle to the index
    ESYS_TR nvHandle = ESYS_TR_NONE;
    rc = Esys_TR_FromTPMPublic(esys, nv_index, ESYS_TR_NONE, ESYS_TR_NONE, ESYS_TR_NONE, &nvHandle);
    if (rc != TSS2_RC_SUCCESS) {
        LOG(ERROR) << "unseal_nvram: TR_FromTPMPublic rc=0x" << std::hex << rc;
        Esys_Finalize(&esys);
        return out;
    }

    // 3) Read public to learn dataSize, nameAlg, attributes
    TPM2B_NV_PUBLIC* pub = nullptr;
    TPM2B_NAME* name = nullptr;
    rc = Esys_NV_ReadPublic(esys, nvHandle, ESYS_TR_NONE, ESYS_TR_NONE, ESYS_TR_NONE, &pub, &name);
    if (rc != TSS2_RC_SUCCESS || !pub) {
        LOG(ERROR) << "unseal_nvram: NV_ReadPublic rc=0x" << std::hex << rc;
        if (name) Esys_Free(name);
        Esys_TR_Close(esys, &nvHandle);
        Esys_Finalize(&esys);
        return out;
    }

    const UINT16 total_size = pub->nvPublic.dataSize;
    const TPMI_ALG_HASH nv_name_alg = pub->nvPublic.nameAlg;
    const TPMA_NV attrs = pub->nvPublic.attributes;

    // 4) Choose authorization mode
    const bool requires_policy = (attrs & TPMA_NV_POLICYREAD) != 0;
    ESYS_TR sh1 = ESYS_TR_NONE, sh2 = ESYS_TR_NONE, sh3 = ESYS_TR_NONE;
    ESYS_TR authHandle = nvHandle; // using index authorization by default

    // Prepare password (for AUTHREAD)
    TPM2B_AUTH indexAuth{};
    indexAuth.size = std::min<size_t>(auth_value.size(), sizeof indexAuth.buffer);
    if (indexAuth.size) memcpy(indexAuth.buffer, auth_value.data(), indexAuth.size);

    ESYS_TR policy = ESYS_TR_NONE; // will hold policy session if used

    if (requires_policy) {
        if (pcrs.empty()) {
            LOG(ERROR) << "unseal_nvram: index requires POLICYREAD but no PCRs were provided";
            Esys_Free(pub); if (name) Esys_Free(name);
            Esys_TR_Close(esys, &nvHandle);
            Esys_Finalize(&esys);
            return out;
        }

        // Start a POLICY session using NV's nameAlg
        TPMT_SYM_DEF symmetric; symmetric.algorithm = TPM2_ALG_NULL;
        TPM2B_NONCE nonce{}; nonce.size = 0;
        rc = Esys_StartAuthSession(esys, ESYS_TR_NONE, ESYS_TR_NONE,
                                   ESYS_TR_NONE, ESYS_TR_NONE, ESYS_TR_NONE,
                                   &nonce, TPM2_SE_POLICY, &symmetric, nv_name_alg, &policy);
        if (rc != TSS2_RC_SUCCESS) {
            LOG(ERROR) << "unseal_nvram: StartAuthSession(policy) rc=0x" << std::hex << rc;
            Esys_Free(pub); if (name) Esys_Free(name);
            Esys_TR_Close(esys, &nvHandle);
            Esys_Finalize(&esys);
            return out;
        }

        // Apply PolicyPCR (must match the selection used to define the index's policy digest)
        TPMS_PCR_SELECTION one{};
        set_pcr_selection(one, parse_hash_algorithm(pcr_bank),
                          std::vector<uint8_t>(pcrs.begin(), pcrs.end()));
        TPML_PCR_SELECTION sels{}; sels.count = 1; sels.pcrSelections[0] = one;

        rc = Esys_PolicyPCR(esys, policy, ESYS_TR_NONE, ESYS_TR_NONE, ESYS_TR_NONE,
                            /*pcrDigest*/nullptr, &sels);
        if (rc != TSS2_RC_SUCCESS) {
            LOG(ERROR) << "unseal_nvram: PolicyPCR rc=0x" << std::hex << rc;
            Esys_FlushContext(esys, policy);
            Esys_Free(pub); if (name) Esys_Free(name);
            Esys_TR_Close(esys, &nvHandle);
            Esys_Finalize(&esys);
            return out;
        }

        sh1 = policy; // authorize NV_Read with the policy session
    } else {
        // Password path
        Esys_TR_SetAuth(esys, nvHandle, &indexAuth);
        sh1 = ESYS_TR_PASSWORD;
    }

    // 5) Read NV in chunks
    out.reserve(total_size);
    UINT16 offset = 0;
    while (offset < total_size) {
        TPM2B_MAX_NV_BUFFER* chunk = nullptr;
        const UINT16 size = std::min<UINT16>(TPM2_MAX_NV_BUFFER_SIZE, total_size - offset);

        rc = Esys_NV_Read(esys, authHandle, nvHandle, sh1, sh2, sh3, size, offset, &chunk);
        if (rc != TSS2_RC_SUCCESS || !chunk) {
            LOG(ERROR) << "unseal_nvram: NV_Read rc=0x" << std::hex << rc
                       << " at offset " << std::dec << offset;
            if (requires_policy && policy != ESYS_TR_NONE) Esys_FlushContext(esys, policy);
            Esys_Free(pub); if (name) Esys_Free(name);
            Esys_TR_Close(esys, &nvHandle);
            Esys_Finalize(&esys);
            return Indigo::Vector<Indigo::uint8_t>(); // empty on failure
        }

        for (UINT16 i = 0; i < chunk->size; ++i) out.push_back(chunk->buffer[i]);
        offset += chunk->size;
        Esys_Free(chunk);
    }

    // 6) Cleanup
    if (requires_policy && policy != ESYS_TR_NONE) Esys_FlushContext(esys, policy);
    Esys_Free(pub); if (name) Esys_Free(name);
    Esys_TR_Close(esys, &nvHandle);
    Esys_Finalize(&esys);
    return out;
}
          </code></pre>
        </div>
      </article>

      <article class="block">
        <div class="block-header">
          <div class="title" contenteditable="true">NULL</div>
          <div>
            <button>Copy</button>
            <button class="btn-green">Download</button>
          </div>
        </div>
        <div class="code-wrap">
          <pre><code contenteditable="true">
            <!-- Your CODE goes here -->
Indigo::bool_t TPMManager_User::seal_nvram(
    Indigo::uint32_t nv_index,
    const TPM::TPMManager::HashAlgorithmEnum& name_alg,
    const Indigo::Vector<Indigo::uint8_t>& auth_value,
    const Indigo::Vector<Indigo::uint8_t>& data,
    const Indigo::Vector<Indigo::uint8_t>& pcrs /* optional */,
    const TPM::TPMManager::HashAlgorithmEnum& pcr_bank /* optional */)
{
    // 0) ESAPI init
    TSS2_ABI_VERSION abi = TSS2_ABI_VERSION_CURRENT;
    ESYS_CONTEXT* esys = nullptr;
    TSS2_RC rc = Esys_Initialize(&esys, p_tcti_context, &abi);
    if (rc != TSS2_RC_SUCCESS) {
        LOG(ERROR) << "seal_nvram: Esys_Initialize rc=0x" << std::hex << rc;
        return false;
    }

    const TPMI_ALG_HASH nv_name_alg = parse_hash_algorithm(name_alg);
    if (nv_name_alg == TPM2_ALG_NULL) { Esys_Finalize(&esys); return false; }

    const bool use_policy = !pcrs.empty();
    const TPMI_ALG_HASH pcr_hash = use_policy ? parse_hash_algorithm(pcr_bank) : TPM2_ALG_NULL;
    if (use_policy && pcr_hash == TPM2_ALG_NULL) { Esys_Finalize(&esys); return false; }

    // 1) Owner auth (default empty unless your platform set one)
    ESYS_TR owner = ESYS_TR_RH_OWNER;
    TPM2B_AUTH ownerAuth{}; ownerAuth.size = 0;
    Esys_TR_SetAuth(esys, owner, &ownerAuth);

    // 2) Build NV public template
    TPM2B_NV_PUBLIC pub{}; pub.size = sizeof(pub.nvPublic);
    pub.nvPublic.nvIndex  = nv_index;
    pub.nvPublic.nameAlg  = nv_name_alg;
    pub.nvPublic.dataSize = static_cast<UINT16>(data.size());
    pub.nvPublic.attributes = TPMA_NV_NO_DA; // good default, add others below

    if (use_policy) {
        pub.nvPublic.attributes |= TPMA_NV_POLICYREAD | TPMA_NV_POLICYWRITE;
        TPM2B_DIGEST policy{};
        if (!build_pcr_policy_digest(esys, nv_name_alg, pcr_hash,
                                     std::vector<uint8_t>(pcrs.begin(), pcrs.end()),
                                     policy)) {
            LOG(ERROR) << "seal_nvram: Policy digest build failed";
            Esys_Finalize(&esys);
            return false;
        }
        pub.nvPublic.authPolicy = policy;
    } else {
        pub.nvPublic.attributes |= TPMA_NV_AUTHREAD | TPMA_NV_AUTHWRITE;
    }

    // 3) Index auth value (PIN/password). Still set even if using policy.
    TPM2B_AUTH indexAuth{}; indexAuth.size =
        std::min<size_t>(auth_value.size(), sizeof indexAuth.buffer);
    if (indexAuth.size) memcpy(indexAuth.buffer, auth_value.data(), indexAuth.size);

    // 4) Define space (correct signature) â†’ returns an ESYS_TR nvHandle
    ESYS_TR nvHandle = ESYS_TR_NONE;
    rc = Esys_NV_DefineSpace(esys, owner,
                             /*sh1*/ESYS_TR_PASSWORD, /*sh2*/ESYS_TR_NONE, /*sh3*/ESYS_TR_NONE,
                             &indexAuth, &pub, &nvHandle);

    if (rc != TSS2_RC_SUCCESS) {
        // If it's already defined, grab a handle and continue; otherwise fail.
        // (Common TPM return for "already defined" is TPM2_RC_NV_DEFINED mapped into TSS2_RC layer.)
        LOG(WARNING) << "seal_nvram: NV_DefineSpace rc=0x" << std::hex << rc
                     << " â€” trying TR_FromTPMPublic";
        rc = Esys_TR_FromTPMPublic(esys, nv_index, ESYS_TR_NONE, ESYS_TR_NONE, ESYS_TR_NONE,
                                   &nvHandle);
        if (rc != TSS2_RC_SUCCESS) {
            LOG(ERROR) << "seal_nvram: TR_FromTPMPublic rc=0x" << std::hex << rc;
            Esys_Finalize(&esys);
            return false;
        }
        // If the existing index has different attributes/policy/size, NV_Write will fail.
        // In that case you may need to NV_UndefineSpace + re-define (requires owner auth).
    }

    // 5) Prepare authorization for the write
    ESYS_TR sh1 = ESYS_TR_NONE, sh2 = ESYS_TR_NONE, sh3 = ESYS_TR_NONE;
    ESYS_TR authHandle = nvHandle;

    if (use_policy) {
        // Start a POLICY session that satisfies PolicyPCR (must match the policy above)
        ESYS_TR policy = ESYS_TR_NONE;
        TPMT_SYM_DEF symmetric; symmetric.algorithm = TPM2_ALG_NULL;
        TPM2B_NONCE nonce{}; nonce.size = 0;

        rc = Esys_StartAuthSession(esys, ESYS_TR_NONE, ESYS_TR_NONE,
                                   ESYS_TR_NONE, ESYS_TR_NONE, ESYS_TR_NONE,
                                   &nonce, TPM2_SE_POLICY, &symmetric, nv_name_alg, &policy);
        if (rc != TSS2_RC_SUCCESS) {
            LOG(ERROR) << "seal_nvram: StartAuthSession(policy) rc=0x" << std::hex << rc;
            if (nvHandle != ESYS_TR_NONE) Esys_TR_Close(esys, &nvHandle);
            Esys_Finalize(&esys);
            return false;
        }

        TPMS_PCR_SELECTION one{};
        set_pcr_selection(one, pcr_hash, std::vector<uint8_t>(pcrs.begin(), pcrs.end()));
        TPML_PCR_SELECTION sels{}; sels.count = 1; sels.pcrSelections[0] = one;

        rc = Esys_PolicyPCR(esys, policy, ESYS_TR_NONE, ESYS_TR_NONE, ESYS_TR_NONE,
                            /*pcrDigest*/nullptr, &sels);
        if (rc != TSS2_RC_SUCCESS) {
            LOG(ERROR) << "seal_nvram: PolicyPCR rc=0x" << std::hex << rc;
            Esys_FlushContext(esys, policy);
            Esys_TR_Close(esys, &nvHandle);
            Esys_Finalize(&esys);
            return false;
        }
        sh1 = policy; // use the policy session to authorize NV_Write
    } else {
        // Password auth on the index itself
        Esys_TR_SetAuth(esys, nvHandle, &indexAuth);
        sh1 = ESYS_TR_PASSWORD;
    }

    // 6) Chunked NV_Write
    UINT16 offset = 0;
    while (offset < data.size()) {
        TPM2B_MAX_NV_BUFFER chunk{};
        const UINT16 n = static_cast<UINT16>(
            std::min<size_t>(TPM2_MAX_NV_BUFFER_SIZE, data.size() - offset));
        chunk.size = n;
        memcpy(chunk.buffer, &data[offset], n);

        rc = Esys_NV_Write(esys, authHandle, nvHandle, sh1, sh2, sh3, &chunk, offset);
        if (rc != TSS2_RC_SUCCESS) {
            LOG(ERROR) << "seal_nvram: NV_Write rc=0x" << std::hex << rc
                       << " at offset " << std::dec << offset;
            if (use_policy && sh1 != ESYS_TR_PASSWORD) Esys_FlushContext(esys, sh1);
            Esys_TR_Close(esys, &nvHandle);
            Esys_Finalize(&esys);
            return false;
        }
        offset += n;
    }

    if (use_policy && sh1 != ESYS_TR_PASSWORD) Esys_FlushContext(esys, sh1);
    Esys_TR_Close(esys, &nvHandle);  // release ESYS handle
    Esys_Finalize(&esys);
    return true;
}

          </code></pre>
        </div>
      </article>
    </section>

    <footer>Built for quick sharing and personal snippets.</footer>
  </div>
</body>
</html>
