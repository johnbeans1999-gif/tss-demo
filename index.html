<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Titled Code Demo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root {
      --bg: #0f172a;
      --panel: #111827;
      --text: #e5e7eb;
      --muted: #9ca3af;
      --accent: #22d3ee;
      --border: #1f2937;
      --btn: #0ea5e9;
      --btn-2: #14b8a6;
      --btn-3: #a78bfa;
      --radius: 12px;
    }

    html, body {
      height: 100%;
      background: radial-gradient(1200px 600px at 20% -10%, #1e293b 0%, #0b1020 40%, var(--bg) 100%);
      color: var(--text);
      margin: 0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial;
    }

    .wrap {
      max-width: 1100px;
      margin: 40px auto 80px;
      padding: 0 16px;
    }

    header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 12px;
      margin-bottom: 20px;
      flex-wrap: wrap;
    }

    h1 {
      margin: 0;
      font-size: 28px;
      letter-spacing: 0.2px;
    }

    .toolbar {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
    }

    button {
      border: none;
      border-radius: 10px;
      padding: 10px 14px;
      font-weight: 600;
      cursor: pointer;
      color: white;
      background: var(--btn);
      transition: transform .05s ease, filter .15s ease;
    }
    button:hover { filter: brightness(1.08); }
    button:active { transform: translateY(1px); }
    .btn-green { background: var(--btn-2); }
    .btn-purple { background: var(--btn-3); }

    /* 1 block per row */
    .grid {
      display: grid;
      grid-template-columns: 1fr;
      gap: 24px;
    }

    .block {
      background: linear-gradient(180deg, rgba(255,255,255,0.06), rgba(255,255,255,0.02));
      border: 1px solid var(--border);
      border-radius: var(--radius);
      overflow: hidden;
      box-shadow: 0 10px 24px rgba(0,0,0,.25);
      display: flex;
      flex-direction: column;
      min-height: 400px; /* bigger block height */
    }

    .block-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      padding: 12px;
      background: rgba(255,255,255,0.03);
      border-bottom: 1px solid var(--border);
    }

    .title {
      font-size: 15px;
      font-weight: 700;
      outline: none;
      border: none;
      background: transparent;
      color: var(--text);
      padding: 6px 8px;
      border-radius: 8px;
    }

    .code-wrap {
      position: relative;
      padding: 12px;
      flex: 1;
    }

    pre {
      margin: 0;
      overflow: auto;
      height: 100%;
      min-height: 350px; /* larger editable area */
      border-radius: 10px;
      border: 1px solid var(--border);
      background: radial-gradient(1200px 400px at 80% -80%, rgba(80,200,255,0.15), transparent 60%),
                  linear-gradient(180deg, rgba(255,255,255,0.03), rgba(255,255,255,0.01));
      padding: 14px;
      font-size: 14px;
      line-height: 1.5;
      color: #e6edf3;
    }

    code[contenteditable="true"] {
      display: block;
      white-space: pre;
      caret-color: #fff;
      outline: none;
    }

    footer {
      text-align: center;
      margin-top: 26px;
      color: var(--muted);
      font-size: 12px;
    }
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <h1>ðŸŽ¯ TPM TSS Demo</h1>
      <div class="toolbar">
        <button class="btn-green">Add New Block</button>
        <button class="btn-purple">Download All</button>
      </div>
    </header>

    <section class="grid">
      <article class="block">
        <div class="block-header">
          <div class="title" contenteditable="true">C++ Snippet</div>
          <div>
            <button>Copy</button>
            <button class="btn-green">Download</button>
          </div>
        </div>
        <div class="code-wrap">
          <pre><code contenteditable="true">
<!-- Your CODE goes here -->
static bool build_pcr_policy_digest(ESYS_CONTEXT* esys,
                                    TPMI_ALG_HASH name_alg,            // session hash == nv nameAlg
                                    TPMI_ALG_HASH pcr_hash_bank,       // PCR bank for selection
                                    const std::vector<uint8_t>& pcrs,  // PCR indices
                                    TPM2B_DIGEST& out_policy)          // filled on success
{
    out_policy.size = 0;

    // Start TRIAL policy session
    ESYS_TR trial = ESYS_TR_NONE;
    TPMT_SYM_DEF symmetric; symmetric.algorithm = TPM2_ALG_NULL;
    TPM2B_NONCE nonce{}; nonce.size = 0;

    TSS2_RC rc = Esys_StartAuthSession(
        esys,
        ESYS_TR_NONE, ESYS_TR_NONE,
        ESYS_TR_NONE, ESYS_TR_NONE, ESYS_TR_NONE,
        &nonce,
        TPM2_SE_TRIAL, &symmetric, name_alg,
        &trial);
    if (rc != TSS2_RC_SUCCESS) return false;

    // Build selection (you already have a helper; reuse it)
    TPMS_PCR_SELECTION one{};
    // uses your helper: set_pcr_selection(TPMS_PCR_SELECTION&, TPMI_ALG_HASH, std::vector<uint8_t>)
    set_pcr_selection(one, pcr_hash_bank, pcrs);

    TPML_PCR_SELECTION sels{};
    sels.count = 1;
    sels.pcrSelections[0] = one;

    // PolicyPCR with current PCR values (binds policy to current state)
    rc = Esys_PolicyPCR(esys, trial,
                        ESYS_TR_NONE, ESYS_TR_NONE, ESYS_TR_NONE,
                        /*pcrDigest*/nullptr, &sels);
    if (rc != TSS2_RC_SUCCESS) {
        Esys_FlushContext(esys, trial);
        return false;
    }

    TPM2B_DIGEST* pd = nullptr;
    rc = Esys_PolicyGetDigest(esys, trial,
                              ESYS_TR_NONE, ESYS_TR_NONE, ESYS_TR_NONE,
                              &pd);
    if (rc == TSS2_RC_SUCCESS && pd && pd->size > 0) {
        out_policy = *pd; // copy
        Esys_Free(pd);
        Esys_FlushContext(esys, trial);
        return true;
    }

    if (pd) Esys_Free(pd);
    Esys_FlushContext(esys, trial);
    return false;
}



          </code></pre>
        </div>
      </article>

      <article class="block">
        <div class="block-header">
          <div class="title" contenteditable="true">NULL</div>
          <div>
            <button>Copy</button>
            <button class="btn-green">Download</button>
          </div>
        </div>
        <div class="code-wrap">
          <pre><code contenteditable="true">
Indigo::bool_t TPMManager_User::seal_nvram(
    Indigo::uint32_t nv_index,
    const TPM::TPMManager::HashAlgorithmEnum& name_alg,
    const Indigo::Vector<Indigo::uint8_t>& auth_value,
    const Indigo::Vector<Indigo::uint8_t>& data,
    const Indigo::Vector<Indigo::uint8_t>& pcrs,
    const TPM::TPMManager::HashAlgorithmEnum& pcr_bank)
{
    // 1) Initialize ESAPI
    TSS2_ABI_VERSION abi = TSS2_ABI_VERSION_CURRENT;
    ESYS_CONTEXT* esys = nullptr;
    TSS2_RC rc = Esys_Initialize(&esys, p_tcti_context, &abi);
    if (rc != TSS2_RC_SUCCESS) {
        LOG(ERROR) << "seal_nvram: Esys_Initialize rc=0x" << std::hex << rc;
        return false;
    }

    // Common handles/auths
    ESYS_TR owner = ESYS_TR_RH_OWNER;
    TPM2B_AUTH ownerAuth{}; ownerAuth.size = 0;            // default empty
    Esys_TR_SetAuth(esys, owner, &ownerAuth);

    // 2) Prepare NV public template
    TPM2B_NV_PUBLIC pub{};
    pub.size = sizeof(pub.nvPublic);
    pub.nvPublic.nvIndex  = nv_index;
    pub.nvPublic.nameAlg  = parse_hash_algorithm(name_alg);
    pub.nvPublic.dataSize = static_cast<UINT16>(data.size());
    pub.nvPublic.attributes = TPMA_NV_NO_DA;   // good default

    const bool use_policy = !pcrs.empty();

    if (use_policy) {
        // Policy protects READ and WRITE
        pub.nvPublic.attributes |= TPMA_NV_POLICYREAD | TPMA_NV_POLICYWRITE;

        // Build authPolicy bound to current PCRs
        TPM2B_DIGEST policy{};
        const TPMI_ALG_HASH pcr_hash = parse_hash_algorithm(pcr_bank);
        if (pcr_hash == TPM2_ALG_NULL ||
            !build_pcr_policy_digest(esys, pub.nvPublic.nameAlg, pcr_hash,
                                     std::vector<uint8_t>(pcrs.begin(), pcrs.end()),
                                     policy)) {
            LOG(ERROR) << "seal_nvram: failed to build PCR policy digest";
            Esys_Finalize(&esys);
            return false;
        }
        pub.nvPublic.authPolicy = policy;
    } else {
        // Password (authValue) protects READ and WRITE
        pub.nvPublic.attributes |= TPMA_NV_AUTHREAD | TPMA_NV_AUTHWRITE;
    }

    // 3) Define the NV space (set initial authValue even if policy is used)
    TPM2B_AUTH indexAuth{};
    indexAuth.size = std::min<size_t>(auth_value.size(), sizeof indexAuth.buffer);
    if (indexAuth.size) {
        memcpy(indexAuth.buffer, auth_value.data(), indexAuth.size);
    }

    rc = Esys_NV_DefineSpace(esys, owner,
                             ESYS_TR_PASSWORD, ESYS_TR_NONE, ESYS_TR_NONE,
                             &indexAuth, &pub);
    if (rc != TSS2_RC_SUCCESS) {
        // If already defined, you could choose to continue instead of failing.
        LOG(ERROR) << "seal_nvram: NV_DefineSpace rc=0x" << std::hex << rc;
        Esys_Finalize(&esys);
        return false;
    }

    // 4) Get a handle to the NV index
    ESYS_TR nvHandle = ESYS_TR_NONE;
    rc = Esys_TR_FromTPMPublic(esys, nv_index,
                               ESYS_TR_NONE, ESYS_TR_NONE, ESYS_TR_NONE,
                               &nvHandle);
    if (rc != TSS2_RC_SUCCESS) {
        LOG(ERROR) << "seal_nvram: TR_FromTPMPublic rc=0x" << std::hex << rc;
        Esys_Finalize(&esys);
        return false;
    }

    // 5) Authorize and write
    ESYS_TR sh1 = ESYS_TR_NONE, sh2 = ESYS_TR_NONE, sh3 = ESYS_TR_NONE;

    ESYS_TR authHandle = nvHandle; // we authorize as the index itself

    if (use_policy) {
        // Start a POLICY session that satisfies PolicyPCR (must match the policy used above)
        ESYS_TR policy = ESYS_TR_NONE;
        TPMT_SYM_DEF symmetric; symmetric.algorithm = TPM2_ALG_NULL;
        TPM2B_NONCE nonce{}; nonce.size = 0;

        rc = Esys_StartAuthSession(
            esys, ESYS_TR_NONE, ESYS_TR_NONE,
            ESYS_TR_NONE, ESYS_TR_NONE, ESYS_TR_NONE,
            &nonce, TPM2_SE_POLICY, &symmetric, pub.nvPublic.nameAlg, &policy);
        if (rc != TSS2_RC_SUCCESS) {
            LOG(ERROR) << "seal_nvram: StartAuthSession(policy) rc=0x" << std::hex << rc;
            Esys_Finalize(&esys);
            return false;
        }

        // Recreate the same selection and call PolicyPCR
        TPMS_PCR_SELECTION one{};
        set_pcr_selection(one, parse_hash_algorithm(pcr_bank),
                          std::vector<uint8_t>(pcrs.begin(), pcrs.end()));
        TPML_PCR_SELECTION sels{}; sels.count = 1; sels.pcrSelections[0] = one;

        rc = Esys_PolicyPCR(esys, policy,
                            ESYS_TR_NONE, ESYS_TR_NONE, ESYS_TR_NONE,
                            /*pcrDigest*/nullptr, &sels);
        if (rc != TSS2_RC_SUCCESS) {
            LOG(ERROR) << "seal_nvram: PolicyPCR (policy session) rc=0x" << std::hex << rc;
            Esys_FlushContext(esys, policy);
            Esys_Finalize(&esys);
            return false;
        }
        // Use policy session as shandle1
        sh1 = policy;
    } else {
        // Password auth on the index
        Esys_TR_SetAuth(esys, nvHandle, &indexAuth);
        sh1 = ESYS_TR_PASSWORD;
    }

    // 6) Chunked write
    UINT16 offset = 0;
    while (offset < data.size()) {
        TPM2B_MAX_NV_BUFFER chunk{};
        const UINT16 n = static_cast<UINT16>(
            std::min<size_t>(TPM2_MAX_NV_BUFFER_SIZE, data.size() - offset));
        chunk.size = n;
        memcpy(chunk.buffer, &data[offset], n);

        rc = Esys_NV_Write(esys, authHandle, nvHandle, sh1, sh2, sh3, &chunk, offset);
        if (rc != TSS2_RC_SUCCESS) {
            LOG(ERROR) << "seal_nvram: NV_Write rc=0x" << std::hex << rc
                       << " at offset " << std::dec << offset;
            if (use_policy && sh1 != ESYS_TR_PASSWORD) Esys_FlushContext(esys, sh1);
            Esys_Finalize(&esys);
            return false;
        }
        offset += n;
    }

    if (use_policy && sh1 != ESYS_TR_PASSWORD) Esys_FlushContext(esys, sh1);
    Esys_Finalize(&esys);
    return true;
}

          </code></pre>
        </div>
      </article>
    </section>

    <footer>Built for quick sharing and personal snippets.</footer>
  </div>
</body>
</html>
